{
    "boilerplate": {
        "prefix": "boilerplate code",
        "body": [
            "//Adarsh Jha",
            "//lowest < current < greatest",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "using namespace chrono;",
            "#define int long long ",
            "#define endl \"\\n\"",
            "typedef pair<int, int> pii;",
            "typedef pair<string, string> pss;",
            "typedef vector<int> vi;",
            "typedef vector<vi> vvi;",
            "typedef vector<pii> vii;",
            "#define repn(a, b, c) for (int(a) = (b); (a) < (c); ++(a))",
            "#define rep(n) repn(i, 0, n)",
            "#define repi(i,n) repn(i, 0, n)",
            "#define pb push_back",
            "#define ALL(v) v.begin(), v.end()",
            "#define ALLA(arr, sz) arr, arr + sz",
            "#define SORTA(arr, sz) sort(ALLA(arr, sz))",
            "#define REVERSEA(arr, sz) reverse(ALLA(arr, sz))",
            "#define PERMUTE next_permutation",
            "#define TC(t) while (t--)",
            "#define mod 1000000007",
            "#define count_set_bits __builtin_popcountll",
            "#define sz(x) ((int)(x).size())",
            "const int N=1e5+1;",
            "#define maxa(arr,n) *max_element(arr, arr+n)",
            "#define mina(arr,n) *min_element(arr, arr+n)",
            "#define pn cout << \"NO\\n\";",
            "#define py cout << \"YES\\n\";",
            "int lcm(int a,int b){return ((a/__gcd(a,b))*b);}",
            "bool isprime(int n){if(n==1||n==0)return false;for(int i=2;i*i<=n;i++){if(n%i==0) return false;}return true;}",
            "void prime_factor(vector<pii> &factorization,int n){for(int i=2; i*i <= n; i++) {int count = 0;while(n % i == 0) {count++;n /= i;}if(count > 0) {factorization.push_back({i, count});}}if(n != 1) {factorization.push_back({n, 1});}}",
            "void divisor(vi &div,int n){for(int i=1;i*i<=n;i++){if(n%i == 0){if(i == n/i)div.push_back(i);else{div.push_back(i);div.push_back(n/i);}}}}",
            "int ncr(int n , int r){  int num =1, deno =1;if(r==0)return 1;    else{while(r>0){num*= n;deno*= r; int temp = __gcd(num , deno);num/= temp;deno/= temp;n--;r--;}}    return num;}",
            "int ceel(int a,int b){if(a%b==0) return a/b;else return a/b+1;}",
            "void convertToLowercase(string &str) {for (char &c : str) {if (c >= 'A' && c <= 'Z') {c = c + 32;}}}",
            "int maximumrepitationofarray(int n,int arr[]){int count=0;int maxcount=1;int c= arr[0];rep(n){if(arr[i]==c){count++;if(count>maxcount){maxcount=count;}}else{count=1;c=arr[i];}}return maxcount;}",
            "bool poweroftwo(int n) {return !(n & (n - 1));}",
            "int power(int A, int B) {int res = 1;while (B > 0) {if (B % 2 == 1) {    res *= A;}A *= A;B /= 2;}return res;}",
            "/*REMOVE LEADING ZEROES",
            "size_t pos = result.find_first_not_of('0');",
            "result = (pos == std::string::npos) ? \"0\" : result.substr(pos);",
            "*/",
            "#define fastio() ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr)",
            "#ifndef ONLINE_JUDGE",
            "#define debug(...) cerr << \"Line:\" << __LINE__ << \" [\" << #__VA_ARGS__ << \"] = [\"; _print(__VA_ARGS__)",
            "#else",
            "#define debug(...)",
            "#endif",
            "/**************CODE_BEGINS_HERE************************************************/",
            "void solve()",
            "{   ",
            "    ",
            "}",
            "/**************CODE_ENDS_ HERE************************************************/",
            "signed main()",
            "{",
            "    fastio();",
            "    auto start1 = high_resolution_clock::now();",
            "   int t=1;cin>>t;while(t--){solve();}",
            "   auto stop1 = high_resolution_clock::now();",
            "   auto duration = duration_cast<microseconds>(stop1 - start1);",
            "   //cerr << \"Time: \" << duration . count() / 1000 << endl;",
            "}"
        ],
        "description": "Boilerplate code for competitive programming."
    },

    "binarysearch": {
            "prefix": "binary search code",
            "body": [
                "bool check(int mid)",
                "{",
                "if(favorable_condition) return 1;",
                    "else return 0;",
                "}",
                "void solve()",
                "{"   ,
                    
                    "int lo=0;   //wherever 0 can be answer use lo=-1",
                   " int hi=1e9;",
                    "int mid;",
                   " //int ans=LLONG_MAX;",
                   " while((hi-lo)>1)",
                  "  {",
                    "    mid=lo+(hi-lo)/2;",
                        "if(check(mid))",
                        "{",
                        "    lo=mid;",
                        "}",
                       " else",
                        "{",
                         "   // used it in some problems ans=min(ans,mid);",
                        "    hi=mid;    //if you are taking mid value also in check function then use hi=mid",
                       " }",
                        
                    "}",
                    "cout<<lo<<endl;  //i had put hi but answer is lo when we draw the predicate function of this",                   
               " }"
            ]

    },
      "shclass": {
    "prefix": "shclass",
    "body": [
      "struct Hashing {",
      "    string s;",
      "    int n;",
      "    int primes;",
      "    vector<int> hashPrimes = {1000000009, 100000007};",
      "    const int base = 31;",
      "    vector<vector<int>> hashValues;",
      "    vector<vector<int>> powersOfBase;",
      "    vector<vector<int>> inversePowersOfBase;",
      "",
      "    Hashing(string a) {",
      "        primes = (int)hashPrimes.size();",
      "        hashValues.resize(primes);",
      "        powersOfBase.resize(primes);",
      "        inversePowersOfBase.resize(primes);",
      "        s = a;",
      "        n = s.length();",
      "",
      "        for (int i = 0; i < primes; i++) {",
      "            powersOfBase[i].resize(n + 1);",
      "            inversePowersOfBase[i].resize(n + 1);",
      "            powersOfBase[i][0] = 1;",
      "            for (int j = 1; j <= n; j++) {",
      "                powersOfBase[i][j] = mod_mul(base, powersOfBase[i][j - 1], hashPrimes[i]);",
      "            }",
      "            inversePowersOfBase[i][n] = mminvprime(powersOfBase[i][n], hashPrimes[i]);",
      "            for (int j = n - 1; j >= 0; j--) {",
      "                inversePowersOfBase[i][j] = mod_mul(inversePowersOfBase[i][j + 1], base, hashPrimes[i]);",
      "            }",
      "        }",
      "",
      "        for (int i = 0; i < primes; i++) {",
      "            hashValues[i].resize(n);",
      "            for (int j = 0; j < n; j++) {",
      "                hashValues[i][j] = mod_mul(s[j] - 'a' + 1LL, powersOfBase[i][j], hashPrimes[i]);",
      "                if (j > 0)",
      "                    hashValues[i][j] = mod_sub(hashValues[i][j] + hashValues[i][j - 1], 0, hashPrimes[i]);",
      "            }",
      "        }",
      "    }",
      "",
      "    vector<int> substringHash(int l, int r) {",
      "        vector<int> hash(primes);",
      "        for (int i = 0; i < primes; i++) {",
      "            int val1 = hashValues[i][r];",
      "            int val2 = l > 0 ? hashValues[i][l - 1] : 0;",
      "            hash[i] = mod_mul(mod_sub(val1, val2, hashPrimes[i]), inversePowersOfBase[i][l], hashPrimes[i]);",
      "        }",
      "        return hash;",
      "    }",
      "",
      "private:",
      "    int mod_mul(int a, int b, int MOD) {",
      "        return (1LL * (a % MOD) * (b % MOD)) % MOD;",
      "    }",
      "",
      "    int mod_sub(int a, int b, int MOD) {",
      "        return (a - b + MOD) % MOD;",
      "    }",
      "",
      "    int binpow(int a, int b, int MOD) {",
      "        int res = 1;",
      "        while (b > 0) {",
      "            if (b & 1)",
      "                res = mod_mul(res, a, MOD);",
      "            a = mod_mul(a, a, MOD);",
      "            b >>= 1;",
      "        }",
      "        return res;",
      "    }",
      "",
      "    int mminvprime(int a, int MOD) {",
      "        return binpow(a, MOD - 2, MOD);",
      "    }",
      "};"
    ],
    "description": "String hashing struct with rolling hash and multiple mod primes."
  },
  "trie": {
    "prefix": "trie",
    "body": [
      "const int ALPHABET = 26;",
      "",
      "struct TrieNode {",
      "    vector<int> children;",
      "    int strings_ending_here;",
      "    int strings_going_below;",
      "",
      "    TrieNode() {",
      "        children.assign(ALPHABET, -1);",
      "        strings_ending_here = 0;",
      "        strings_going_below = 0;",
      "    }",
      "};",
      "",
      "struct Trie {",
      "    vector<TrieNode> tree;",
      "    int size;",
      "",
      "    Trie() {",
      "        tree.emplace_back();",
      "        size = 1;",
      "    }",
      "",
      "    void insert(const string& word) {",
      "        int node = 0;",
      "        for (char ch : word) {",
      "            int c = ch - 'a';",
      "            if (tree[node].children[c] == -1) {",
      "                tree[node].children[c] = size++;",
      "                tree.emplace_back();",
      "            }",
      "            node = tree[node].children[c];",
      "            tree[node].strings_going_below++;",
      "        }",
      "        tree[node].strings_ending_here++;",
      "    }",
      "",
      "    bool search(const string& word) {",
      "        int node = 0;",
      "        for (char ch : word) {",
      "            int c = ch - 'a';",
      "            if (tree[node].children[c] == -1)",
      "                return false;",
      "            node = tree[node].children[c];",
      "        }",
      "        return tree[node].strings_ending_here > 0;",
      "    }",
      "",
      "    bool startsWith(const string& prefix) {",
      "        int node = 0;",
      "        for (char ch : prefix) {",
      "            int c = ch - 'a';",
      "            if (tree[node].children[c] == -1)",
      "                return false;",
      "            node = tree[node].children[c];",
      "        }",
      "        return true;",
      "    }",
      "",
      "    void deleteWord(const string& word) {",
      "        if (!search(word)) return;",
      "",
      "        int node = 0;",
      "        for (char ch : word) {",
      "            int c = ch - 'a';",
      "            int child = tree[node].children[c];",
      "",
      "            tree[child].strings_going_below--;",
      "            if (tree[child].strings_going_below == 0 && tree[child].strings_ending_here == 0) {",
      "                tree[node].children[c] = -1;",
      "            }",
      "",
      "            node = child;",
      "        }",
      "        tree[node].strings_ending_here--;",
      "    }",
      "};"
    ],
    "description": "Efficient Trie implementation using vector-based nodes."
  },
    "Binary Trie": {
    "prefix": "binarytrie",
    "body": [
      "const int MAX_BITS = 63; // For 64-bit unsigned integers",
      "",
      "struct BinaryTrieNode {",
      "    int child[2];",
      "    int strings_going_below;",
      "    int strings_ending_here;",
      "",
      "    BinaryTrieNode() {",
      "        child[0] = child[1] = -1;",
      "        strings_going_below = 0;",
      "        strings_ending_here = 0;",
      "    }",
      "};",
      "",
      "struct BinaryTrie {",
      "    vector<BinaryTrieNode> trie;",
      "",
      "    BinaryTrie() {",
      "        trie.push_back(BinaryTrieNode());",
      "    }",
      "",
      "    void insert(uint64_t num) {",
      "        int node = 0;",
      "        for (int i = MAX_BITS; i >= 0; i--) {",
      "            int bit = (num >> i) & 1;",
      "            if (trie[node].child[bit] == -1) {",
      "                trie[node].child[bit] = trie.size();",
      "                trie.push_back(BinaryTrieNode());",
      "            }",
      "            node = trie[node].child[bit];",
      "            trie[node].strings_going_below++;",
      "        }",
      "        trie[node].strings_ending_here++;",
      "    }",
      "",
      "    bool search(uint64_t num) {",
      "        int node = 0;",
      "        for (int i = MAX_BITS; i >= 0; i--) {",
      "            int bit = (num >> i) & 1;",
      "            if (trie[node].child[bit] == -1)",
      "                return false;",
      "            node = trie[node].child[bit];",
      "        }",
      "        return trie[node].strings_ending_here > 0;",
      "    }",
      "",
      "    void erase(uint64_t num) {",
      "        if (!search(num)) return;",
      "        int node = 0;",
      "        for (int i = MAX_BITS; i >= 0; i--) {",
      "            int bit = (num >> i) & 1;",
      "            int next = trie[node].child[bit];",
      "            trie[next].strings_going_below--;",
      "            if (trie[next].strings_going_below == 0)",
      "                trie[node].child[bit] = -1;",
      "            node = next;",
      "        }",
      "        trie[node].strings_ending_here--;",
      "    }",
      "};"
    ],
    "description": "64-bit Binary Trie with strings_going_below and strings_ending_here counters"
  }
}
